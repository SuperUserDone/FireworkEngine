// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: scene.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 8000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "entity.capnp.h"
#include "vector.capnp.h"

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(a161f2ef428ad8f3);
CAPNP_DECLARE_SCHEMA(84ec7d47da394ec1);
CAPNP_DECLARE_SCHEMA(e94cea6b10cd563c);
CAPNP_DECLARE_SCHEMA(aa55a7dbd61d63e8);
CAPNP_DECLARE_SCHEMA(b1bef838f3080e38);

}  // namespace schemas
}  // namespace capnp

namespace fw {
namespace capnp {

struct Texture {
  Texture() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    PATH,
    SIZE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a161f2ef428ad8f3, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Material {
  Material() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(84ec7d47da394ec1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Key = ::capnp::AnyPointer, typename Value = ::capnp::AnyPointer>
struct Map {
  Map() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Entry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e94cea6b10cd563c, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Key, Value>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Key, typename Value>
struct Map<Key, Value>::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa55a7dbd61d63e8, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Key, Value>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Scene {
  Scene() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b1bef838f3080e38, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Texture::Reader {
public:
  typedef Texture Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isPath() const;
  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

  inline bool isSize() const;
  inline bool hasSize() const;
  inline  ::fw::capnp::Vec2u::Reader getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Texture::Builder {
public:
  typedef Texture Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isPath();
  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

  inline bool isSize();
  inline bool hasSize();
  inline  ::fw::capnp::Vec2u::Builder getSize();
  inline void setSize( ::fw::capnp::Vec2u::Reader value);
  inline  ::fw::capnp::Vec2u::Builder initSize();
  inline void adoptSize(::capnp::Orphan< ::fw::capnp::Vec2u>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Vec2u> disownSize();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Texture::Pipeline {
public:
  typedef Texture Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Material::Reader {
public:
  typedef Material Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTextures() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getTextures() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Material::Builder {
public:
  typedef Material Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTextures();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getTextures();
  inline void setTextures( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setTextures(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initTextures(unsigned int size);
  inline void adoptTextures(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownTextures();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Material::Pipeline {
public:
  typedef Material Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Key, typename Value>
class Map<Key, Value>::Reader {
public:
  typedef Map Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Reader asGeneric() {
    return typename Map<Key2, Value2>::Reader(_reader);
  }

  inline bool hasEntries() const;
  inline typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key, typename Value>
class Map<Key, Value>::Builder {
public:
  typedef Map Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Builder asGeneric() {
    return typename Map<Key2, Value2>::Builder(_builder);
  }

  inline bool hasEntries();
  inline typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries(typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key, typename Value>
class Map<Key, Value>::Pipeline {
public:
  typedef Map Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Key, typename Value>
class Map<Key, Value>::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Entry::Reader asMapGeneric() {
    return typename Map<Key2, Value2>::Entry::Reader(_reader);
  }

  inline bool hasKey() const;
  inline  ::capnp::ReaderFor<Key> getKey() const;

  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<Value> getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key, typename Value>
class Map<Key, Value>::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Entry::Builder asMapGeneric() {
    return typename Map<Key2, Value2>::Entry::Builder(_builder);
  }

  inline bool hasKey();
  inline  ::capnp::BuilderFor<Key> getKey();
  inline void setKey( ::capnp::ReaderFor<Key> value);
  inline  ::capnp::BuilderFor<Key> initKey();
  inline  ::capnp::BuilderFor<Key> initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan<Key>&& value);
  inline ::capnp::Orphan<Key> disownKey();

  inline bool hasValue();
  inline  ::capnp::BuilderFor<Value> getValue();
  inline void setValue( ::capnp::ReaderFor<Value> value);
  inline  ::capnp::BuilderFor<Value> initValue();
  inline  ::capnp::BuilderFor<Value> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<Value>&& value);
  inline ::capnp::Orphan<Value> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key, typename Value>
class Map<Key, Value>::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Key> getKey();
  inline  ::capnp::PipelineFor<Value> getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Scene::Reader {
public:
  typedef Scene Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasMaterials() const;
  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Reader getMaterials() const;

  inline bool hasTextures() const;
  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Reader getTextures() const;

  inline bool hasEntities() const;
  inline  ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Reader getEntities() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Scene::Builder {
public:
  typedef Scene Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasMaterials();
  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Builder getMaterials();
  inline void setMaterials( ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Reader value);
  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Builder initMaterials();
  inline void adoptMaterials(::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>> disownMaterials();

  inline bool hasTextures();
  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Builder getTextures();
  inline void setTextures( ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Reader value);
  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Builder initTextures();
  inline void adoptTextures(::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>> disownTextures();

  inline bool hasEntities();
  inline  ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Builder getEntities();
  inline void setEntities( ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Builder initEntities(unsigned int size);
  inline void adoptEntities(::capnp::Orphan< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>> disownEntities();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Scene::Pipeline {
public:
  typedef Scene Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Pipeline getMaterials();
  inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Pipeline getTextures();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::fw::capnp::Texture::Which Texture::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::fw::capnp::Texture::Which Texture::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Texture::Reader::isPath() const {
  return which() == Texture::PATH;
}
inline bool Texture::Builder::isPath() {
  return which() == Texture::PATH;
}
inline bool Texture::Reader::hasPath() const {
  if (which() != Texture::PATH) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Texture::Builder::hasPath() {
  if (which() != Texture::PATH) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Texture::Reader::getPath() const {
  KJ_IREQUIRE((which() == Texture::PATH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Texture::Builder::getPath() {
  KJ_IREQUIRE((which() == Texture::PATH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Texture::Builder::setPath( ::capnp::Text::Reader value) {
  _builder.setDataField<Texture::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Texture::PATH);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Texture::Builder::initPath(unsigned int size) {
  _builder.setDataField<Texture::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Texture::PATH);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Texture::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Texture::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Texture::PATH);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Texture::Builder::disownPath() {
  KJ_IREQUIRE((which() == Texture::PATH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Texture::Reader::isSize() const {
  return which() == Texture::SIZE;
}
inline bool Texture::Builder::isSize() {
  return which() == Texture::SIZE;
}
inline bool Texture::Reader::hasSize() const {
  if (which() != Texture::SIZE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Texture::Builder::hasSize() {
  if (which() != Texture::SIZE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Vec2u::Reader Texture::Reader::getSize() const {
  KJ_IREQUIRE((which() == Texture::SIZE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec2u>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Vec2u::Builder Texture::Builder::getSize() {
  KJ_IREQUIRE((which() == Texture::SIZE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec2u>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Texture::Builder::setSize( ::fw::capnp::Vec2u::Reader value) {
  _builder.setDataField<Texture::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Texture::SIZE);
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec2u>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Vec2u::Builder Texture::Builder::initSize() {
  _builder.setDataField<Texture::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Texture::SIZE);
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec2u>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Texture::Builder::adoptSize(
    ::capnp::Orphan< ::fw::capnp::Vec2u>&& value) {
  _builder.setDataField<Texture::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Texture::SIZE);
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec2u>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Vec2u> Texture::Builder::disownSize() {
  KJ_IREQUIRE((which() == Texture::SIZE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec2u>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Material::Reader::hasTextures() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Material::Builder::hasTextures() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Material::Reader::getTextures() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Material::Builder::getTextures() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Material::Builder::setTextures( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Material::Builder::setTextures(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Material::Builder::initTextures(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Material::Builder::adoptTextures(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Material::Builder::disownTextures() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader Map<Key, Value>::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder Map<Key, Value>::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Builder::setEntries(typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder Map<Key, Value>::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>> Map<Key, Value>::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::fw::capnp::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Key> Map<Key, Value>::Entry::Reader::getKey() const {
  return ::capnp::_::PointerHelpers<Key>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::getKey() {
  return ::capnp::_::PointerHelpers<Key>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Key> Map<Key, Value>::Entry::Pipeline::getKey() {
  return  ::capnp::PipelineFor<Key>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::setKey( ::capnp::ReaderFor<Key> value) {
  ::capnp::_::PointerHelpers<Key>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::initKey() {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::adoptKey(
    ::capnp::Orphan<Key>&& value) {
  ::capnp::_::PointerHelpers<Key>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Key> Map<Key, Value>::Entry::Builder::disownKey() {
  return ::capnp::_::PointerHelpers<Key>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Value> Map<Key, Value>::Entry::Reader::getValue() const {
  return ::capnp::_::PointerHelpers<Value>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::getValue() {
  return ::capnp::_::PointerHelpers<Value>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Value> Map<Key, Value>::Entry::Pipeline::getValue() {
  return  ::capnp::PipelineFor<Value>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::setValue( ::capnp::ReaderFor<Value> value) {
  ::capnp::_::PointerHelpers<Value>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::initValue() {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::adoptValue(
    ::capnp::Orphan<Value>&& value) {
  ::capnp::_::PointerHelpers<Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Value> Map<Key, Value>::Entry::Builder::disownValue() {
  return ::capnp::_::PointerHelpers<Value>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Map<Key, Value>::Entry
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::Entry::_capnpPrivate::dataWordSize;
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::Entry::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Key, typename Value>
constexpr ::capnp::Kind Map<Key, Value>::Entry::_capnpPrivate::kind;
template <typename Key, typename Value>
constexpr ::capnp::_::RawSchema const* Map<Key, Value>::Entry::_capnpPrivate::schema;
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Scope Map<Key, Value>::Entry::_capnpPrivate::brandScopes[] = {
  { 0xe94cea6b10cd563c, brandBindings + 0, 2, false},
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Binding Map<Key, Value>::Entry::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema Map<Key, Value>::Entry::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_aa55a7dbd61d63e8, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Map<Key, Value>
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::_capnpPrivate::dataWordSize;
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Key, typename Value>
constexpr ::capnp::Kind Map<Key, Value>::_capnpPrivate::kind;
template <typename Key, typename Value>
constexpr ::capnp::_::RawSchema const* Map<Key, Value>::_capnpPrivate::schema;
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Scope Map<Key, Value>::_capnpPrivate::brandScopes[] = {
  { 0xe94cea6b10cd563c, brandBindings + 0, 2, false},
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Binding Map<Key, Value>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Dependency Map<Key, Value>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::fw::capnp::Map<Key, Value>::Entry::_capnpPrivate::brand() },
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema Map<Key, Value>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e94cea6b10cd563c, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

inline bool Scene::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Scene::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Scene::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Scene::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Scene::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Scene::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Scene::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Scene::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Scene::Reader::hasMaterials() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Scene::Builder::hasMaterials() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Reader Scene::Reader::getMaterials() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Builder Scene::Builder::getMaterials() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Pipeline Scene::Pipeline::getMaterials() {
  return  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Scene::Builder::setMaterials( ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>::Builder Scene::Builder::initMaterials() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Scene::Builder::adoptMaterials(
    ::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>> Scene::Builder::disownMaterials() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Material>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Scene::Reader::hasTextures() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Scene::Builder::hasTextures() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Reader Scene::Reader::getTextures() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Builder Scene::Builder::getTextures() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Pipeline Scene::Pipeline::getTextures() {
  return  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Scene::Builder::setTextures( ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>::Builder Scene::Builder::initTextures() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Scene::Builder::adoptTextures(
    ::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>> Scene::Builder::disownTextures() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Map< ::capnp::Text,  ::fw::capnp::Texture>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Scene::Reader::hasEntities() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Scene::Builder::hasEntities() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Reader Scene::Reader::getEntities() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Builder Scene::Builder::getEntities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Scene::Builder::setEntities( ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>::Builder Scene::Builder::initEntities(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Scene::Builder::adoptEntities(
    ::capnp::Orphan< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>> Scene::Builder::disownEntities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::fw::capnp::Entity,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

