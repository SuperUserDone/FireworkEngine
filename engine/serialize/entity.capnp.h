// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: entity.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 8000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "vector.capnp.h"

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(94b6d250c3adc4e1);
CAPNP_DECLARE_SCHEMA(b3919c27d4a14f3f);
CAPNP_DECLARE_SCHEMA(cb075bca875e54a2);
CAPNP_DECLARE_SCHEMA(be87ccb5daae5404);

}  // namespace schemas
}  // namespace capnp

namespace fw {
namespace capnp {

struct ComponentCamera {
  ComponentCamera() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94b6d250c3adc4e1, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentMeshRenderer {
  ComponentMeshRenderer() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3919c27d4a14f3f, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentTransform {
  ComponentTransform() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb075bca875e54a2, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Entity {
  Entity() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be87ccb5daae5404, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class ComponentCamera::Reader {
public:
  typedef ComponentCamera Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getClipFar() const;

  inline float getClipNear() const;

  inline float getFov() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentCamera::Builder {
public:
  typedef ComponentCamera Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getClipFar();
  inline void setClipFar(float value);

  inline float getClipNear();
  inline void setClipNear(float value);

  inline float getFov();
  inline void setFov(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentCamera::Pipeline {
public:
  typedef ComponentCamera Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentMeshRenderer::Reader {
public:
  typedef ComponentMeshRenderer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMeshRefrence() const;
  inline  ::capnp::Text::Reader getMeshRefrence() const;

  inline bool hasMatRefrence() const;
  inline  ::capnp::Text::Reader getMatRefrence() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentMeshRenderer::Builder {
public:
  typedef ComponentMeshRenderer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMeshRefrence();
  inline  ::capnp::Text::Builder getMeshRefrence();
  inline void setMeshRefrence( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initMeshRefrence(unsigned int size);
  inline void adoptMeshRefrence(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownMeshRefrence();

  inline bool hasMatRefrence();
  inline  ::capnp::Text::Builder getMatRefrence();
  inline void setMatRefrence( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initMatRefrence(unsigned int size);
  inline void adoptMatRefrence(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownMatRefrence();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentMeshRenderer::Pipeline {
public:
  typedef ComponentMeshRenderer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentTransform::Reader {
public:
  typedef ComponentTransform Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPos() const;
  inline  ::fw::capnp::Vec3f::Reader getPos() const;

  inline bool hasRot() const;
  inline  ::fw::capnp::Vec4f::Reader getRot() const;

  inline bool hasScale() const;
  inline  ::fw::capnp::Vec3f::Reader getScale() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentTransform::Builder {
public:
  typedef ComponentTransform Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPos();
  inline  ::fw::capnp::Vec3f::Builder getPos();
  inline void setPos( ::fw::capnp::Vec3f::Reader value);
  inline  ::fw::capnp::Vec3f::Builder initPos();
  inline void adoptPos(::capnp::Orphan< ::fw::capnp::Vec3f>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Vec3f> disownPos();

  inline bool hasRot();
  inline  ::fw::capnp::Vec4f::Builder getRot();
  inline void setRot( ::fw::capnp::Vec4f::Reader value);
  inline  ::fw::capnp::Vec4f::Builder initRot();
  inline void adoptRot(::capnp::Orphan< ::fw::capnp::Vec4f>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Vec4f> disownRot();

  inline bool hasScale();
  inline  ::fw::capnp::Vec3f::Builder getScale();
  inline void setScale( ::fw::capnp::Vec3f::Reader value);
  inline  ::fw::capnp::Vec3f::Builder initScale();
  inline void adoptScale(::capnp::Orphan< ::fw::capnp::Vec3f>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Vec3f> disownScale();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentTransform::Pipeline {
public:
  typedef ComponentTransform Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fw::capnp::Vec3f::Pipeline getPos();
  inline  ::fw::capnp::Vec4f::Pipeline getRot();
  inline  ::fw::capnp::Vec3f::Pipeline getScale();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Entity::Reader {
public:
  typedef Entity Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint32_t getId() const;

  inline bool hasCamera() const;
  inline  ::fw::capnp::ComponentCamera::Reader getCamera() const;

  inline bool hasMeshRenderer() const;
  inline  ::fw::capnp::ComponentMeshRenderer::Reader getMeshRenderer() const;

  inline bool hasTransform() const;
  inline  ::fw::capnp::ComponentTransform::Reader getTransform() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Entity::Builder {
public:
  typedef Entity Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline bool hasCamera();
  inline  ::fw::capnp::ComponentCamera::Builder getCamera();
  inline void setCamera( ::fw::capnp::ComponentCamera::Reader value);
  inline  ::fw::capnp::ComponentCamera::Builder initCamera();
  inline void adoptCamera(::capnp::Orphan< ::fw::capnp::ComponentCamera>&& value);
  inline ::capnp::Orphan< ::fw::capnp::ComponentCamera> disownCamera();

  inline bool hasMeshRenderer();
  inline  ::fw::capnp::ComponentMeshRenderer::Builder getMeshRenderer();
  inline void setMeshRenderer( ::fw::capnp::ComponentMeshRenderer::Reader value);
  inline  ::fw::capnp::ComponentMeshRenderer::Builder initMeshRenderer();
  inline void adoptMeshRenderer(::capnp::Orphan< ::fw::capnp::ComponentMeshRenderer>&& value);
  inline ::capnp::Orphan< ::fw::capnp::ComponentMeshRenderer> disownMeshRenderer();

  inline bool hasTransform();
  inline  ::fw::capnp::ComponentTransform::Builder getTransform();
  inline void setTransform( ::fw::capnp::ComponentTransform::Reader value);
  inline  ::fw::capnp::ComponentTransform::Builder initTransform();
  inline void adoptTransform(::capnp::Orphan< ::fw::capnp::ComponentTransform>&& value);
  inline ::capnp::Orphan< ::fw::capnp::ComponentTransform> disownTransform();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Entity::Pipeline {
public:
  typedef Entity Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fw::capnp::ComponentCamera::Pipeline getCamera();
  inline  ::fw::capnp::ComponentMeshRenderer::Pipeline getMeshRenderer();
  inline  ::fw::capnp::ComponentTransform::Pipeline getTransform();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline float ComponentCamera::Reader::getClipFar() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float ComponentCamera::Builder::getClipFar() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ComponentCamera::Builder::setClipFar(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ComponentCamera::Reader::getClipNear() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ComponentCamera::Builder::getClipNear() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ComponentCamera::Builder::setClipNear(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ComponentCamera::Reader::getFov() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ComponentCamera::Builder::getFov() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ComponentCamera::Builder::setFov(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool ComponentMeshRenderer::Reader::hasMeshRefrence() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentMeshRenderer::Builder::hasMeshRefrence() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ComponentMeshRenderer::Reader::getMeshRefrence() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ComponentMeshRenderer::Builder::getMeshRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentMeshRenderer::Builder::setMeshRefrence( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ComponentMeshRenderer::Builder::initMeshRefrence(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ComponentMeshRenderer::Builder::adoptMeshRefrence(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ComponentMeshRenderer::Builder::disownMeshRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentMeshRenderer::Reader::hasMatRefrence() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentMeshRenderer::Builder::hasMatRefrence() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ComponentMeshRenderer::Reader::getMatRefrence() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ComponentMeshRenderer::Builder::getMatRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ComponentMeshRenderer::Builder::setMatRefrence( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ComponentMeshRenderer::Builder::initMatRefrence(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void ComponentMeshRenderer::Builder::adoptMatRefrence(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ComponentMeshRenderer::Builder::disownMatRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ComponentTransform::Reader::hasPos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentTransform::Builder::hasPos() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Vec3f::Reader ComponentTransform::Reader::getPos() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::getPos() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Vec3f::Pipeline ComponentTransform::Pipeline::getPos() {
  return  ::fw::capnp::Vec3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ComponentTransform::Builder::setPos( ::fw::capnp::Vec3f::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::initPos() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentTransform::Builder::adoptPos(
    ::capnp::Orphan< ::fw::capnp::Vec3f>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Vec3f> ComponentTransform::Builder::disownPos() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentTransform::Reader::hasRot() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentTransform::Builder::hasRot() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Vec4f::Reader ComponentTransform::Reader::getRot() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Vec4f::Builder ComponentTransform::Builder::getRot() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Vec4f::Pipeline ComponentTransform::Pipeline::getRot() {
  return  ::fw::capnp::Vec4f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ComponentTransform::Builder::setRot( ::fw::capnp::Vec4f::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Vec4f::Builder ComponentTransform::Builder::initRot() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ComponentTransform::Builder::adoptRot(
    ::capnp::Orphan< ::fw::capnp::Vec4f>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Vec4f> ComponentTransform::Builder::disownRot() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ComponentTransform::Reader::hasScale() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentTransform::Builder::hasScale() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Vec3f::Reader ComponentTransform::Reader::getScale() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::getScale() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Vec3f::Pipeline ComponentTransform::Pipeline::getScale() {
  return  ::fw::capnp::Vec3f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void ComponentTransform::Builder::setScale( ::fw::capnp::Vec3f::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::initScale() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ComponentTransform::Builder::adoptScale(
    ::capnp::Orphan< ::fw::capnp::Vec3f>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Vec3f> ComponentTransform::Builder::disownScale() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Entity::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Entity::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Entity::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Entity::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Entity::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Entity::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Entity::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Entity::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Entity::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Entity::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Entity::Reader::hasCamera() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasCamera() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::ComponentCamera::Reader Entity::Reader::getCamera() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::ComponentCamera::Builder Entity::Builder::getCamera() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::ComponentCamera::Pipeline Entity::Pipeline::getCamera() {
  return  ::fw::capnp::ComponentCamera::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Entity::Builder::setCamera( ::fw::capnp::ComponentCamera::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::ComponentCamera::Builder Entity::Builder::initCamera() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Entity::Builder::adoptCamera(
    ::capnp::Orphan< ::fw::capnp::ComponentCamera>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::ComponentCamera> Entity::Builder::disownCamera() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Entity::Reader::hasMeshRenderer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasMeshRenderer() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::ComponentMeshRenderer::Reader Entity::Reader::getMeshRenderer() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMeshRenderer>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::ComponentMeshRenderer::Builder Entity::Builder::getMeshRenderer() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMeshRenderer>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::ComponentMeshRenderer::Pipeline Entity::Pipeline::getMeshRenderer() {
  return  ::fw::capnp::ComponentMeshRenderer::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Entity::Builder::setMeshRenderer( ::fw::capnp::ComponentMeshRenderer::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMeshRenderer>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::ComponentMeshRenderer::Builder Entity::Builder::initMeshRenderer() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMeshRenderer>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Entity::Builder::adoptMeshRenderer(
    ::capnp::Orphan< ::fw::capnp::ComponentMeshRenderer>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMeshRenderer>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::ComponentMeshRenderer> Entity::Builder::disownMeshRenderer() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMeshRenderer>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Entity::Reader::hasTransform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasTransform() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::ComponentTransform::Reader Entity::Reader::getTransform() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::ComponentTransform::Builder Entity::Builder::getTransform() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::ComponentTransform::Pipeline Entity::Pipeline::getTransform() {
  return  ::fw::capnp::ComponentTransform::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Entity::Builder::setTransform( ::fw::capnp::ComponentTransform::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::ComponentTransform::Builder Entity::Builder::initTransform() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Entity::Builder::adoptTransform(
    ::capnp::Orphan< ::fw::capnp::ComponentTransform>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::ComponentTransform> Entity::Builder::disownTransform() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

