// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: entity.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 8000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "vector.capnp.h"

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(94b6d250c3adc4e1);
CAPNP_DECLARE_SCHEMA(90853abb41461dcd);
CAPNP_DECLARE_SCHEMA(9aed93409b9d19c7);
CAPNP_DECLARE_SCHEMA(cb075bca875e54a2);
CAPNP_DECLARE_SCHEMA(be87ccb5daae5404);

}  // namespace schemas
}  // namespace capnp

namespace fw {
namespace capnp {

struct ComponentCamera {
  ComponentCamera() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94b6d250c3adc4e1, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentMesh {
  ComponentMesh() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(90853abb41461dcd, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentMaterial {
  ComponentMaterial() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9aed93409b9d19c7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ComponentTransform {
  ComponentTransform() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb075bca875e54a2, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Entity {
  Entity() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be87ccb5daae5404, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class ComponentCamera::Reader {
public:
  typedef ComponentCamera Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getClipFar() const;

  inline float getClipNear() const;

  inline float getFov() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentCamera::Builder {
public:
  typedef ComponentCamera Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getClipFar();
  inline void setClipFar(float value);

  inline float getClipNear();
  inline void setClipNear(float value);

  inline float getFov();
  inline void setFov(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentCamera::Pipeline {
public:
  typedef ComponentCamera Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentMesh::Reader {
public:
  typedef ComponentMesh Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRefrence() const;
  inline  ::capnp::Text::Reader getRefrence() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentMesh::Builder {
public:
  typedef ComponentMesh Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRefrence();
  inline  ::capnp::Text::Builder getRefrence();
  inline void setRefrence( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initRefrence(unsigned int size);
  inline void adoptRefrence(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownRefrence();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentMesh::Pipeline {
public:
  typedef ComponentMesh Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentMaterial::Reader {
public:
  typedef ComponentMaterial Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRefrence() const;
  inline  ::capnp::Text::Reader getRefrence() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentMaterial::Builder {
public:
  typedef ComponentMaterial Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRefrence();
  inline  ::capnp::Text::Builder getRefrence();
  inline void setRefrence( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initRefrence(unsigned int size);
  inline void adoptRefrence(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownRefrence();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentMaterial::Pipeline {
public:
  typedef ComponentMaterial Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComponentTransform::Reader {
public:
  typedef ComponentTransform Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPos() const;
  inline  ::fw::capnp::Vec3f::Reader getPos() const;

  inline bool hasRot() const;
  inline  ::fw::capnp::Vec4f::Reader getRot() const;

  inline bool hasScale() const;
  inline  ::fw::capnp::Vec3f::Reader getScale() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComponentTransform::Builder {
public:
  typedef ComponentTransform Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPos();
  inline  ::fw::capnp::Vec3f::Builder getPos();
  inline void setPos( ::fw::capnp::Vec3f::Reader value);
  inline  ::fw::capnp::Vec3f::Builder initPos();
  inline void adoptPos(::capnp::Orphan< ::fw::capnp::Vec3f>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Vec3f> disownPos();

  inline bool hasRot();
  inline  ::fw::capnp::Vec4f::Builder getRot();
  inline void setRot( ::fw::capnp::Vec4f::Reader value);
  inline  ::fw::capnp::Vec4f::Builder initRot();
  inline void adoptRot(::capnp::Orphan< ::fw::capnp::Vec4f>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Vec4f> disownRot();

  inline bool hasScale();
  inline  ::fw::capnp::Vec3f::Builder getScale();
  inline void setScale( ::fw::capnp::Vec3f::Reader value);
  inline  ::fw::capnp::Vec3f::Builder initScale();
  inline void adoptScale(::capnp::Orphan< ::fw::capnp::Vec3f>&& value);
  inline ::capnp::Orphan< ::fw::capnp::Vec3f> disownScale();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComponentTransform::Pipeline {
public:
  typedef ComponentTransform Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fw::capnp::Vec3f::Pipeline getPos();
  inline  ::fw::capnp::Vec4f::Pipeline getRot();
  inline  ::fw::capnp::Vec3f::Pipeline getScale();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Entity::Reader {
public:
  typedef Entity Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint32_t getId() const;

  inline bool hasCamera() const;
  inline  ::fw::capnp::ComponentCamera::Reader getCamera() const;

  inline bool hasMesh() const;
  inline  ::fw::capnp::ComponentMesh::Reader getMesh() const;

  inline bool hasTransform() const;
  inline  ::fw::capnp::ComponentTransform::Reader getTransform() const;

  inline bool hasMaterial() const;
  inline  ::fw::capnp::ComponentMaterial::Reader getMaterial() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Entity::Builder {
public:
  typedef Entity Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline bool hasCamera();
  inline  ::fw::capnp::ComponentCamera::Builder getCamera();
  inline void setCamera( ::fw::capnp::ComponentCamera::Reader value);
  inline  ::fw::capnp::ComponentCamera::Builder initCamera();
  inline void adoptCamera(::capnp::Orphan< ::fw::capnp::ComponentCamera>&& value);
  inline ::capnp::Orphan< ::fw::capnp::ComponentCamera> disownCamera();

  inline bool hasMesh();
  inline  ::fw::capnp::ComponentMesh::Builder getMesh();
  inline void setMesh( ::fw::capnp::ComponentMesh::Reader value);
  inline  ::fw::capnp::ComponentMesh::Builder initMesh();
  inline void adoptMesh(::capnp::Orphan< ::fw::capnp::ComponentMesh>&& value);
  inline ::capnp::Orphan< ::fw::capnp::ComponentMesh> disownMesh();

  inline bool hasTransform();
  inline  ::fw::capnp::ComponentTransform::Builder getTransform();
  inline void setTransform( ::fw::capnp::ComponentTransform::Reader value);
  inline  ::fw::capnp::ComponentTransform::Builder initTransform();
  inline void adoptTransform(::capnp::Orphan< ::fw::capnp::ComponentTransform>&& value);
  inline ::capnp::Orphan< ::fw::capnp::ComponentTransform> disownTransform();

  inline bool hasMaterial();
  inline  ::fw::capnp::ComponentMaterial::Builder getMaterial();
  inline void setMaterial( ::fw::capnp::ComponentMaterial::Reader value);
  inline  ::fw::capnp::ComponentMaterial::Builder initMaterial();
  inline void adoptMaterial(::capnp::Orphan< ::fw::capnp::ComponentMaterial>&& value);
  inline ::capnp::Orphan< ::fw::capnp::ComponentMaterial> disownMaterial();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Entity::Pipeline {
public:
  typedef Entity Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::fw::capnp::ComponentCamera::Pipeline getCamera();
  inline  ::fw::capnp::ComponentMesh::Pipeline getMesh();
  inline  ::fw::capnp::ComponentTransform::Pipeline getTransform();
  inline  ::fw::capnp::ComponentMaterial::Pipeline getMaterial();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline float ComponentCamera::Reader::getClipFar() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float ComponentCamera::Builder::getClipFar() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ComponentCamera::Builder::setClipFar(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ComponentCamera::Reader::getClipNear() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ComponentCamera::Builder::getClipNear() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ComponentCamera::Builder::setClipNear(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ComponentCamera::Reader::getFov() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ComponentCamera::Builder::getFov() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ComponentCamera::Builder::setFov(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool ComponentMesh::Reader::hasRefrence() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentMesh::Builder::hasRefrence() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ComponentMesh::Reader::getRefrence() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ComponentMesh::Builder::getRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentMesh::Builder::setRefrence( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ComponentMesh::Builder::initRefrence(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ComponentMesh::Builder::adoptRefrence(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ComponentMesh::Builder::disownRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentMaterial::Reader::hasRefrence() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentMaterial::Builder::hasRefrence() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ComponentMaterial::Reader::getRefrence() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ComponentMaterial::Builder::getRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentMaterial::Builder::setRefrence( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ComponentMaterial::Builder::initRefrence(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ComponentMaterial::Builder::adoptRefrence(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ComponentMaterial::Builder::disownRefrence() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentTransform::Reader::hasPos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentTransform::Builder::hasPos() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Vec3f::Reader ComponentTransform::Reader::getPos() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::getPos() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Vec3f::Pipeline ComponentTransform::Pipeline::getPos() {
  return  ::fw::capnp::Vec3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ComponentTransform::Builder::setPos( ::fw::capnp::Vec3f::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::initPos() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ComponentTransform::Builder::adoptPos(
    ::capnp::Orphan< ::fw::capnp::Vec3f>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Vec3f> ComponentTransform::Builder::disownPos() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ComponentTransform::Reader::hasRot() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentTransform::Builder::hasRot() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Vec4f::Reader ComponentTransform::Reader::getRot() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Vec4f::Builder ComponentTransform::Builder::getRot() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Vec4f::Pipeline ComponentTransform::Pipeline::getRot() {
  return  ::fw::capnp::Vec4f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ComponentTransform::Builder::setRot( ::fw::capnp::Vec4f::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Vec4f::Builder ComponentTransform::Builder::initRot() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ComponentTransform::Builder::adoptRot(
    ::capnp::Orphan< ::fw::capnp::Vec4f>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Vec4f> ComponentTransform::Builder::disownRot() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec4f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ComponentTransform::Reader::hasScale() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ComponentTransform::Builder::hasScale() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::Vec3f::Reader ComponentTransform::Reader::getScale() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::getScale() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::Vec3f::Pipeline ComponentTransform::Pipeline::getScale() {
  return  ::fw::capnp::Vec3f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void ComponentTransform::Builder::setScale( ::fw::capnp::Vec3f::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::Vec3f::Builder ComponentTransform::Builder::initScale() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ComponentTransform::Builder::adoptScale(
    ::capnp::Orphan< ::fw::capnp::Vec3f>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::Vec3f> ComponentTransform::Builder::disownScale() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::Vec3f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Entity::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Entity::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Entity::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Entity::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Entity::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Entity::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Entity::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Entity::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Entity::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Entity::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Entity::Reader::hasCamera() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasCamera() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::ComponentCamera::Reader Entity::Reader::getCamera() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::ComponentCamera::Builder Entity::Builder::getCamera() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::ComponentCamera::Pipeline Entity::Pipeline::getCamera() {
  return  ::fw::capnp::ComponentCamera::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Entity::Builder::setCamera( ::fw::capnp::ComponentCamera::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::ComponentCamera::Builder Entity::Builder::initCamera() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Entity::Builder::adoptCamera(
    ::capnp::Orphan< ::fw::capnp::ComponentCamera>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::ComponentCamera> Entity::Builder::disownCamera() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentCamera>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Entity::Reader::hasMesh() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasMesh() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::ComponentMesh::Reader Entity::Reader::getMesh() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMesh>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::ComponentMesh::Builder Entity::Builder::getMesh() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMesh>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::ComponentMesh::Pipeline Entity::Pipeline::getMesh() {
  return  ::fw::capnp::ComponentMesh::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Entity::Builder::setMesh( ::fw::capnp::ComponentMesh::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMesh>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::ComponentMesh::Builder Entity::Builder::initMesh() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMesh>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Entity::Builder::adoptMesh(
    ::capnp::Orphan< ::fw::capnp::ComponentMesh>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMesh>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::ComponentMesh> Entity::Builder::disownMesh() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMesh>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Entity::Reader::hasTransform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasTransform() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::ComponentTransform::Reader Entity::Reader::getTransform() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::ComponentTransform::Builder Entity::Builder::getTransform() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::ComponentTransform::Pipeline Entity::Pipeline::getTransform() {
  return  ::fw::capnp::ComponentTransform::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Entity::Builder::setTransform( ::fw::capnp::ComponentTransform::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::ComponentTransform::Builder Entity::Builder::initTransform() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Entity::Builder::adoptTransform(
    ::capnp::Orphan< ::fw::capnp::ComponentTransform>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::ComponentTransform> Entity::Builder::disownTransform() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentTransform>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Entity::Reader::hasMaterial() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Entity::Builder::hasMaterial() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::fw::capnp::ComponentMaterial::Reader Entity::Reader::getMaterial() const {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMaterial>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::fw::capnp::ComponentMaterial::Builder Entity::Builder::getMaterial() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMaterial>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::fw::capnp::ComponentMaterial::Pipeline Entity::Pipeline::getMaterial() {
  return  ::fw::capnp::ComponentMaterial::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Entity::Builder::setMaterial( ::fw::capnp::ComponentMaterial::Reader value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMaterial>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::fw::capnp::ComponentMaterial::Builder Entity::Builder::initMaterial() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMaterial>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Entity::Builder::adoptMaterial(
    ::capnp::Orphan< ::fw::capnp::ComponentMaterial>&& value) {
  ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMaterial>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::fw::capnp::ComponentMaterial> Entity::Builder::disownMaterial() {
  return ::capnp::_::PointerHelpers< ::fw::capnp::ComponentMaterial>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

